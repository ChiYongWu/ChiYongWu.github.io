<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://chiyongwu.github.io</id>
    <title>SwordPal&apos;s blog</title>
    <updated>2021-01-22T12:00:02.922Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://chiyongwu.github.io"/>
    <link rel="self" href="https://chiyongwu.github.io/atom.xml"/>
    <subtitle>等候未来的你</subtitle>
    <logo>https://chiyongwu.github.io/images/avatar.png</logo>
    <icon>https://chiyongwu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, SwordPal&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【Nginx】负载均衡]]></title>
        <id>https://chiyongwu.github.io/post/nginx-fu-zai-jun-heng/</id>
        <link href="https://chiyongwu.github.io/post/nginx-fu-zai-jun-heng/">
        </link>
        <updated>2021-01-22T09:18:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-关于nginx的负载均衡">一、关于Nginx的负载均衡</h1>
<p>在服务器集群中，Nginx起到一个代理服务器的角色（即反向代理），为了避免单独一个服务器压力过大，将来自用户的请求转发给不同的服务器。详情请查看我的<a href="https://www.cnblogs.com/1214804270hacker/p/9277895.html">另一篇博客</a>。</p>
<h1 id="二-nginx负载均衡策略">二、Nginx负载均衡策略</h1>
<p>负载均衡用于从“upstream”模块定义的后端服务器列表中选取一台服务器接受用户的请求。一个最基本的upstream模块是这样的，模块内的server是服务器列表：</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
    server localhost:8080;  #tomcat 7.0
    server localhost:8081;  #tomcat 8.0
    server localhost:8082;  #tomcat 8.5
    server localhost:8083;  #tomcat 9.0
}
</code></pre>
<p>在upstream模块配置完成后，要让指定的访问反向代理到服务器列表：</p>
<pre><code>#其他页面反向代理到tomcat容器
location ~ .*$ {
	index index.jsp index.html;
	proxy_pass http://dynamic_zuoyu;
}
</code></pre>
<p>这就是最基本的负载均衡实例，但这不足以满足实际需求；目前Nginx服务器的upstream模块支持6种方式的分配：</p>
<table>
<thead>
<tr>
<th>轮询</th>
<th>默认方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>weight</td>
<td>权重方式</td>
</tr>
<tr>
<td>ip_hash</td>
<td>依据ip分配方式</td>
</tr>
<tr>
<td>least_conn</td>
<td>最少连接方式</td>
</tr>
<tr>
<td>fair（第三方）</td>
<td>响应时间方式</td>
</tr>
<tr>
<td>url_hash（第三方）</td>
<td>依据URL分配方式</td>
</tr>
</tbody>
</table>
<p>在这里，只详细说明Nginx自带的负载均衡策略，第三方不多描述。</p>
<h2 id="1-轮询">1、轮询</h2>
<p>最基本的配置方法，上面的例子就是轮询的方式，它是upstream模块默认的负载均衡默认策略。每个请求会按时间顺序逐一分配到不同的后端服务器。</p>
<p>有如下参数：</p>
<table>
<thead>
<tr>
<th>fail_timeout</th>
<th>与max_fails结合使用。</th>
</tr>
</thead>
<tbody>
<tr>
<td>max_fails</td>
<td>设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了，</td>
</tr>
<tr>
<td>fail_time</td>
<td>服务器会被认为停机的时间长度,默认为10s。</td>
</tr>
<tr>
<td>backup</td>
<td>标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。</td>
</tr>
<tr>
<td>down</td>
<td>标记服务器永久停机了。</td>
</tr>
</tbody>
</table>
<p>注意：</p>
<ul>
<li>在轮询中，如果服务器down掉了，会自动剔除该服务器。</li>
<li>缺省配置就是轮询策略。</li>
<li>此策略适合服务器配置相当，无状态且短平快的服务使用。</li>
</ul>
<h2 id="2-weight">2、weight</h2>
<p>权重方式，在轮询策略的基础上指定轮询的几率。例子如下：</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
    server localhost:8080   weight=2;  #tomcat 7.0
    server localhost:8081;  #tomcat 8.0
    server localhost:8082   backup;  #tomcat 8.5
    server localhost:8083   max_fails=3 fail_timeout=20s;  #tomcat 9.0
}
</code></pre>
<p>在该例子中，weight参数用于指定轮询几率，weight的默认值为1,；weight的数值与访问比率成正比，比如Tomcat 7.0被访问的几率为其他服务器的两倍。</p>
<p>注意：</p>
<ul>
<li>权重越高分配到需要处理的请求越多。</li>
<li>此策略可以与least_conn和ip_hash结合使用。</li>
<li>此策略比较适合服务器的硬件配置差别比较大的情况。</li>
</ul>
<h2 id="3-ip_hash">3、ip_hash</h2>
<p>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
  ip_hash; #保证每个访客固定访问一个后端服务器
  server localhost:8080 weight=2; #tomcat 7.0
  server localhost:8081; #tomcat 8.0
  server localhost:8082; #tomcat 8.5
  server localhost:8083 max_fails=3 fail_timeout=20s; #tomcat 9.0
}
</code></pre>
<p>注意：</p>
<ul>
<li>在nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。</li>
<li>ip_hash不能与backup同时使用。</li>
<li>此策略适合有状态服务，比如session。</li>
<li>当有服务器需要剔除，必须手动down掉。</li>
</ul>
<h2 id="4-least_conn">4、least_conn</h2>
<p>把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
  least_conn; #把请求转发给连接数较少的后端服务器
  server localhost:8080 weight=2; #tomcat 7.0
  server localhost:8081; #tomcat 8.0
  server localhost:8082 backup; #tomcat 8.5
  server localhost:8083 max_fails=3 fail_timeout=20s; #tomcat 9.0
}
</code></pre>
<p>注意：</p>
<ul>
<li>此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。</li>
</ul>
<h2 id="5-第三方策略">5、第三方策略</h2>
<p>第三方的负载均衡策略的实现需要安装第三方插件。</p>
<h3 id="1fair">①fair</h3>
<p>按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
  server localhost:8080; #tomcat 7.0
  server localhost:8081; #tomcat 8.0
  server localhost:8082; #tomcat 8.5
  server localhost:8083; #tomcat 9.0
  fair; #实现响应时间短的优先分配
}
</code></pre>
<h3 id="2url_hash">②url_hash</h3>
<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，要配合缓存命中来使用。同一个资源多次请求，可能会到达不同的服务器上，导致不必要的多次下载，缓存命中率不高，以及一些资源时间的浪费。而使用url_hash，可以使得同一个url（也就是同一个资源请求）会到达同一台服务器，一旦缓存住了资源，再此收到请求，就可以从缓存中读取。</p>
<pre><code>#动态服务器组
upstream dynamic_zuoyu {
  hash $request_uri; #实现每个url定向到同一个后端服务器
  server localhost:8080; #tomcat 7.0
  server localhost:8081; #tomcat 8.0
  server localhost:8082; #tomcat 8.5
  server localhost:8083; #tomcat 9.0
}
</code></pre>
<h1 id="三-总结">三、总结</h1>
<p>以上便是6种负载均衡策略的实现方式，其中除了轮询和轮询权重外，都是Nginx根据不同的算法实现的。在实际运用中，需要根据不同的场景选择性运用，大都是多种策略结合使用以达到实际需求。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Nginx】实现动静分离]]></title>
        <id>https://chiyongwu.github.io/post/nginx-shi-xian-dong-jing-fen-chi/</id>
        <link href="https://chiyongwu.github.io/post/nginx-shi-xian-dong-jing-fen-chi/">
        </link>
        <updated>2021-01-22T05:13:41.000Z</updated>
        <content type="html"><![CDATA[<h2 id="一-概述">一、概述</h2>
<h3 id="11-动态页面与静态页面区别">1.1 动态页面与静态页面区别</h3>
<ul>
<li>静态资源： 当用户多次访问这个资源，资源的源代码永远不会改变的资源。</li>
<li>动态资源：当用户多次访问这个资源，资源的源代码可能会发送改变。</li>
</ul>
<h3 id="12-什么是动静分离">1.2 什么是动静分离</h3>
<ul>
<li>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</li>
<li>动静分离简单的概括是：动态文件与静态文件的分离。</li>
<li>伪静态：网站如果想被搜索引擎搜素到，动态页面静态技术freemarker等模版引擎技术</li>
</ul>
<h3 id="13-为什么要用动静分离">1.3 为什么要用动静分离</h3>
<ul>
<li>在我们的软件开发中，有些请求是需要后台处理的（如：.jsp,.do等等），有些请求是不需要经过后台处理的（如：css、html、jpg、js等等文件），这些不需要经过后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。这会有人又说那我后台忽略静态文件不就完了吗。当然这是可以的，但是这样后台的请求次数就明显增多了。在我们对资源的响应速度有要求的时候，我们应该使用这种动静分离的策略去解决。</li>
<li>动静分离将网站静态资源（HTML，JavaScript，CSS，img等文件）与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。这里我们将静态资源放到nginx中，动态资源转发到tomcat服务器中。</li>
<li>因此，动态资源转发到tomcat服务器我们就使用到了前面讲到的反向代理了。</li>
</ul>
<h2 id="二-nginx实现动静分离">二、Nginx实现动静分离</h2>
<h3 id="21-架构分析">2.1 架构分析</h3>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/WuChiYong/markdown_picture/raw/master/img/20210122125440.jpg" alt="img" loading="lazy"></figure>
<h3 id="22-配置">2.2 配置</h3>
<p>动静分离的原理很简单，通过location对请求url进行匹配即可，在**/Users/Hao/Desktop/Test**（任意目录）下创建 <strong>/static/imgs</strong> 配置如下：</p>
<pre><code class="language-shell">###静态资源访问
server {
  listen       80;
  server_name  static.haoworld.com;
  location /static/imgs {
       root /Users/Hao/Desktop/Test;
       index  index.html index.htm;
   }
}
###动态资源访问
 server {
  listen       80;
  server_name  www.haoworld.com;
    
  location / {
    proxy_pass http://127.0.0.1:8080;
     index  index.html index.htm;
   }
}
</code></pre>
<h2 id="三-动静分离与前后分离区别">三、动静分离与前后分离区别:</h2>
<ol>
<li>动静分离动态资源与静态资源分离，不会部署在同一台服务器上。</li>
<li>前后分离:网站架构模式，微服务开发基于<code>SOA</code>面向于服务器开发，后台和前端都采用调用接口方式。将一个项目拆分成一个控制<code>Web</code>(前端)和接口(后端),最终使用rpc远程调用技术。视图层和业务逻辑层拆分，中间采用<code>RPC</code>远程调用技术</li>
</ol>
<h2 id="四-一些问题">四、一些问题</h2>
<ol>
<li>为什么互联网公司项目中，静态资源URL后面会加上一个时间戳？他的作用：控制缓存
<ul>
<li>目的：最终的目的是为了控制项目上线的时候，新静态资源与老的浏览器缓存静态资源避免冲突问题。</li>
<li>解决办法:加上时间戳规范t = 项目上线</li>
</ul>
</li>
<li>304走本地缓存状态码原理:
<ul>
<li>默认浏览器图片缓存是7天。</li>
<li>第一次下载资源的时候，客户端保存修改资源时间</li>
<li>第二次下载资源的时候，服务端判断客户端上一次修改的时间是否需返回200还是304</li>
<li>第二次下载资源的时候，服务端判断当前资源文件与客户端上一次修改的时间是否需返回200还是304客户端第二次下载资源最后修改时间 2018/6/28 下午11:07:11</li>
<li>服务端最后一次修改时间大于客户端最后一次修改的时间200重 新加载资源</li>
<li>服务器端最后一次修改的时间小于客户端最后修改的时间返回304走本地缓存</li>
</ul>
</li>
</ol>
<p>生产环境中js css最后一次的修改时间与客户端缓存的最后一次修改的时间可能会产生<br>
冲突。服务器在2018年5月22日上线，用户在2018年6月01日访问，用户上线新js文件在2018年06月5日最后一次修改时间还是保留上次上线时间。所以一般来说在服务器上线的时候，都会在静态资源上加上时间戳 强制最新的资源</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Win下Nginx安装部署实战]]></title>
        <id>https://chiyongwu.github.io/post/win-xia-nginx-an-zhuang-bu-shu-shi-zhan/</id>
        <link href="https://chiyongwu.github.io/post/win-xia-nginx-an-zhuang-bu-shu-shi-zhan/">
        </link>
        <updated>2021-01-21T03:30:27.000Z</updated>
        <content type="html"><![CDATA[<h3 id="安装">安装</h3>
<p>http://nginx.org/</p>
<h3 id="启动">启动</h3>
<p>启动方式很多，可以双击nginx解压目录下的nginx.exe启动nginx，出现一闪而过的窗口，是正常的，表示nginx服务器已经启动；</p>
<p>也可以在cmd命令窗口输入命令 nginx，使用命令到达nginx的加压缩后的目录，然后输入nginx命令，如下所示。</p>
<figure data-type="image" tabindex="1"><img src="https://gitee.com/WuChiYong/markdown_picture/raw/master/img/20210121111022" alt="图片" loading="lazy"></figure>
<p>在浏览器地址框输入地址，</p>
<p>http://localhost:80</p>
<p>或者http://127.0.0.1:80</p>
<p>或者http://localhost</p>
<p>或者http://127.0.0.1</p>
<p>然后浏览器出现如下信息，说明nginx启动成功。</p>
<figure data-type="image" tabindex="2"><img src="https://gitee.com/WuChiYong/markdown_picture/raw/master/img/20210121111321" alt="图片" loading="lazy"></figure>
<h3 id="配置">配置</h3>
<ol>
<li>
<p>修改端口号</p>
<p>conf目录下的nginx.conf，默认配置的nginx监听的端口为80，如果80端口被占用可以修改为未被占用的端口即可。</p>
</li>
</ol>
<figure data-type="image" tabindex="3"><img src="https://gitee.com/WuChiYong/markdown_picture/raw/master/img/20210121111953" alt="图片" loading="lazy"></figure>
<p><strong>注意：</strong></p>
<ol>
<li>
<p>检查80端口是否被占用的命令是：netstat -ano | findstr “80”</p>
<p>当我们修改了nginx的配置文件nginx.conf 时，不需要关闭nginx后重新启动nginx，只需要执行命令 nginx -s reload 即可让改动生效。</p>
</li>
<li>
<p>配置静态资源</p>
<p>在解压缩的nginx目录下新建static目录，在该目录下拷贝粘贴一张图片资源1.jpg。</p>
</li>
</ol>
<figure data-type="image" tabindex="4"><img src="https://gitee.com/WuChiYong/markdown_picture/raw/master/img/20210121112653.png" alt="image-20210121112653634" loading="lazy"></figure>
<p>​		然后执行命令 nginx -s reload 即可实现修改生效，然后在浏览器地址栏输入访问地址：http://localhost/1.jpg</p>
<h3 id="停止">停止</h3>
<p>​		如果使用cmd命令窗口启动nginx，关闭cmd窗口是不能结束nginx进程的，可使用如下三种方法关闭nginx。</p>
<ol>
<li>nginx -s stop(快速停止nginx)  或nginx -s quit(完整有序的停止nginx)</li>
<li>taskkill /f /t /im nginx.exe</li>
<li>任务管理器中结束nginx任务</li>
</ol>
<p>总结：以上是windows环境下常用的下载、安装、启动、配置、停止等操作步骤。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[yarn使用教程]]></title>
        <id>https://chiyongwu.github.io/post/yarn-shi-yong-jiao-cheng/</id>
        <link href="https://chiyongwu.github.io/post/yarn-shi-yong-jiao-cheng/">
        </link>
        <updated>2021-01-17T06:09:19.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-yarn的简介">一、yarn的简介：</h3>
<p>Yarn是facebook发布的一款取代npm的包管理工具。</p>
<h3 id="二-yarn的特点">二、yarn的特点：</h3>
<p>1.速度超快。<br>
Yarn 缓存了每个下载过的包，所以再次使用时无需重复下载。 同时利用并行下载以最大化资源利用率，因此安装速度更快。<br>
2.超级安全。<br>
在执行代码之前，Yarn 会通过算法校验每个安装包的完整性。<br>
3.超级可靠。<br>
使用详细、简洁的锁文件格式和明确的安装算法，Yarn 能够保证在不同系统上无差异的工作。</p>
<h3 id="三-yarn的安装">三、yarn的安装:</h3>
<h5 id="下载nodejs使用npm安装">下载node.js，使用npm安装</h5>
<p>npm install -g yarn</p>
<h5 id="查看版本">查看版本：</h5>
<p>yarn --version</p>
<h5 id="yarn-淘宝源安装">Yarn 淘宝源安装</h5>
<p>yarn config set registry <a href="https://registry.npm.taobao.org/">https://registry.npm.taobao.org</a> -g<br>
yarn config set sass_binary_site http://cdn.npm.taobao.org/dist/node-sass -g</p>
<h3 id="四-yarn的常用命令">四、yarn的常用命令：</h3>
<p>安装yarn<br>
npm install -g yarn<br>
安装成功后，查看版本号：<br>
yarn --version<br>
创建文件夹 yarn<br>
md yarn<br>
进入yarn文件夹<br>
cd yarn<br>
初始化项目<br>
yarn init // 同npm init，执行输入信息后，会生成package.json文件<br>
yarn的配置项：<br>
yarn config list // 显示所有配置项<br>
yarn config get //显示某配置项<br>
yarn config delete //删除某配置项<br>
yarn config set [-g|--global] //设置配置项<br>
安装包：<br>
yarn install <a href="https://xn--package-4g6m3574a.xn--json-8h0gt02f9uhek3g/">//安装package.json里所有包</a>，并将包及它的所有依赖项保存进yarn.lock<br>
yarn install --flat //安装一个包的单一版本<br>
yarn install --force //强制重新下载所有包<br>
yarn install --production //只安装dependencies里的包<br>
yarn install --no-lockfile <a href="https://xn--yarn-fb5fm02ao2zmbx542a609b.lock/">//不读取或生成yarn.lock</a><br>
yarn install --pure-lockfile <a href="https://xn--yarn-fb5f137h141a.lock/">//不生成yarn.lock</a><br>
添加包（会更新package.json和yarn.lock）：</p>
<p>yarn add [package] // 在当前的项目中添加一个依赖包，会自动更新到package.json和yarn.lock文件中<br>
yarn add [package]@[version] // 安装指定版本，这里指的是主要版本，如果需要精确到小版本，使用-E参数<br>
yarn add [package]@[tag] // 安装某个tag（比如beta,next或者latest）<br>
//不指定依赖类型默认安装到dependencies里，你也可以指定依赖类型：</p>
<p>yarn add --dev/-D // 加到 devDependencies<br>
yarn add --peer/-P // 加到 peerDependencies<br>
yarn add --optional/-O // 加到 optionalDependencies<br>
//默认安装包的主要版本里的最新版本，下面两个命令可以指定版本：</p>
<p>yarn add --exact/-E // 安装包的精确版本。例如yarn add foo@1.2.3会接受1.9.1版，但是yarn add foo@1.2.3 --exact只会接受1.2.3版<br>
yarn add --tilde/-T // 安装包的次要版本里的最新版。例如yarn add foo@1.2.3 --tilde会接受1.2.9，但不接受1.3.0<br>
发布包</p>
<p>yarn publish<br>
移除一个包<br>
yarn remove ：移除一个包，会自动更新package.json和yarn.lock<br>
更新一个依赖<br>
yarn upgrade 用于更新包到基于规范范围的最新版本<br>
运行脚本<br>
yarn run 用来执行在 package.json 中 scripts 属性下定义的脚本<br>
显示某个包的信息<br>
yarn info 可以用来查看某个模块的最新版本信息<br>
缓存<br>
yarn cache<br>
yarn cache list # 列出已缓存的每个包<br>
yarn cache dir # 返回 全局缓存位置<br>
yarn cache clean # 清除缓存</p>
<h3 id="五-npm-与-yarn命令比较">五、npm 与 yarn命令比较:</h3>
<p>比如说你的项目模块依赖是图中描述的，@1.2.1代表这个模块的版本。在你安装A的时候需要安装依赖C和D，很多依赖不会指定版本号，默认会安装最新的版本，这样就会出现问题：比如今天安装模块的时候C和D是某一个版本，而当以后C、D更新的时候，再次安装模块就会安装C和D的最新版本，如果新的版本无法兼容你的项目，你的程序可能就会出BUG，甚至无法运行。这就是npm的弊端，而yarn为了解决这个问题推出了yarn.lock的机制，这是作者项目中的yarn.lock文件。</p>
<p>大家会看到，这个文件已经把依赖模块的版本号全部锁定，当你执行yarn install的时候，yarn会读取这个文件获得依赖的版本号，然后依照这个版本号去安装对应的依赖模块，这样依赖就会被锁定，以后再也不用担心版本号的问题了。其他人或者其他环境下使用的时候，把这个yarn.lock拷贝到相应的环境项目下再安装即可。<br>
注意：这个文件不要手动修改它，当你使用一些操作如yarn add时，yarn会自动更新yarn.lock。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[git终端代理设置]]></title>
        <id>https://chiyongwu.github.io/post/git-zhong-duan-dai-li-she-zhi/</id>
        <link href="https://chiyongwu.github.io/post/git-zhong-duan-dai-li-she-zhi/">
        </link>
        <updated>2021-01-13T21:16:31.000Z</updated>
        <content type="html"><![CDATA[<h3 id="git设置和取消代理">git设置和取消代理</h3>
<h4 id="方法1永久设置">方法1：永久设置</h4>
<pre><code># 设置ss
git config --global http.proxy 'socks5://127.0.0.1:端口号'

git config --global https.proxy 'socks5://127.0.0.1:端口号'

# 设置代理
git config --global https.proxy http://127.0.0.1:端口号

git config --global https.proxy https://127.0.0.1:端口号

# 取消代理
git config --global --unset http.proxy

git config --global --unset https.proxy
</code></pre>
<h4 id="方法2临时设置">方法2：临时设置</h4>
<pre><code># 设置ss
export http_proxy=&quot;socks5://127.0.0.1:端口号&quot;
export https_proxy=&quot;socks5://127.0.0.1:端口号&quot;

# 设置代理
export http_proxy='http://127.0.0.1:端口号'
export https_proxy='http://127.0.0.1:端口号'
</code></pre>
<h4 id="方法3直接修改gitconfig文件">方法3：直接修改.gitconfig文件</h4>
<pre><code># 打开该文件，追加以下内容：

[http &quot;https://github.com&quot;]
    proxy = socks5://127.0.0.1:端口号
</code></pre>
<h4 id="方法4第三方平台代理下载">方法4：第三方平台代理下载</h4>
<pre><code>http://gitd.cc/

https://gitclone.com/
</code></pre>
<h4 id="方法5利用gitee克隆导入github项目">方法5：利用gitee克隆/导入github项目</h4>
<pre><code>https://zhuanlan.zhihu.com/p/112697807
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[nvm安装配置教程]]></title>
        <id>https://chiyongwu.github.io/post/nvm-an-zhuang-pei-zhi-jiao-cheng/</id>
        <link href="https://chiyongwu.github.io/post/nvm-an-zhuang-pei-zhi-jiao-cheng/">
        </link>
        <updated>2021-01-03T16:36:21.000Z</updated>
        <content type="html"><![CDATA[<p>转载：https://www.longkui.site/development/nvm%e7%9a%84%e5%ae%89%e8%a3%85%e9%85%8d%e7%bd%ae%e4%b8%8e%e4%bd%bf%e7%94%a8/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[docker教程]]></title>
        <id>https://chiyongwu.github.io/post/docker-jiao-cheng/</id>
        <link href="https://chiyongwu.github.io/post/docker-jiao-cheng/">
        </link>
        <updated>2021-01-03T16:28:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="一-centos-7安装docker-ce">一、centos 7安装docker ce</h3>
<p>1、安装依赖包</p>
<pre><code>yum install -y yum-utils device-mapper-persistent-data lvm2
</code></pre>
<p>2、设置国内yum源</p>
<pre><code>yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre>
<p>3、安装docker</p>
<pre><code>yum install -y docker-ce
</code></pre>
<p>4、启动/关闭docker服务</p>
<pre><code>systemctl start docker
systemctl stop docker
</code></pre>
<h3 id="二-常用命令">二、常用命令</h3>
<pre><code>搜索镜像：docker search [imageName]
拉取镜像: docker pull [imageName]:[image Tag]
查看本地镜像: docker images
运行容器: docker run [imageId]
查看运行中的docker：docker ps
查看所有历史容器：docker ps -a
查看docker容器日志：docker logs [-f] [containerId]
进入容器：docker exec -it [containerId] /bin/bash
docker拷贝文件：docker cp [localPath] [containerId]:[containerPath]
启动/停止/重启已存在的容器：docker start/stop/restart [containerId]
移除docker容器：docker rm [containerId]（容器必须在停止状态才能移除）
删除镜像：docker rmi [imageId]

-d：后台运行镜像
-t：启动一个终端
-i：标准输入
-p：容器內的端口映射到本机端口
-v：文件映射
</code></pre>
<h3 id="三-项目部署">三、项目部署</h3>
<p>原则：不要把配置文件和数据放在容器中，请在宿主机上创建配置文件目录和数据文件目录，再通过文件映射方式提供容器使用。</p>
<p>dockerhub网站可以搜镜像的使用方法，比如mysql：https://hub.docker.com/_/mysql</p>
<p>注意：</p>
<p>从宿主机外面访问宿主机上的容器，IP地址只需要填宿主机，端口填映射端口即可访问容器。若是容器间的通信，则不能填宿主机的IP和映射端口。同一个宿主机中的docker间通信，可以通过docker内部IP来访问。容器间的通信有如下3种方法：</p>
<ul>
<li>docker inspect [containerId]</li>
<li>每次重启容器都会变更IP，因此应进行docker网络创建。通过在docker run命令中让容器加入已有的docker网络，并起容器网络别名的方式，实现容器网络创建</li>
</ul>
<h3 id="四-docker网络创建">四、docker网络创建</h3>
<pre><code>docker network create beihe-network //创建docker网络
docker network ls //查看网络
</code></pre>
<p>举例：</p>
<pre><code>docker run -d -p 3306:3306 --network beihe-network --network-alias mysql-network --privileged=true -v /home/docker/mysql/conf/my.cnf:/etc/mysql/my.cnf -v /home/docker/mysql /data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7.21
	

--network-alias：网络别名，当IP使用，直接写在配置文件中的ip位置
</code></pre>
<h3 id="五-dockerfile创建镜像">五、dockerfile创建镜像</h3>
<p>若要做镜像，请基于别人做好的镜像再做。比如java项目，去dockerhub下载java镜像，步骤如下：</p>
<pre><code>FROM hub.c.163.com/library/java  //拉取java容器镜像
RUN mkdir -p /home/app  //为容器创建目录
COPY pinter.jar /home/app  //将java项目拷贝到容器目录
WORKDIR /home/app  //设置工作目录
EXPOSE 8080  //设置端口号
CMD java -jar pinter.jar  //执行命令
</code></pre>
<p>生成镜像：</p>
<pre><code>docker build -t pinter:tagName .  //.是路径上下文
</code></pre>
<p>更多命令参考：https://www.runoob.com/docker/docker-dockerfile.html</p>
<p>RUN命令和CMD命令的区别：</p>
<p>RUN命令只在build时执行，CMD是每次容器运行时执行。</p>
<h3 id="六-docker-compose">六、docker-compose</h3>
<p>直接去http://get.daocloud.io/#install-compose下载docker compose，验证是否安装成功：</p>
<pre><code>docker-compose -v
</code></pre>
<p>docker-compose文件是yaml配置文件，模板：</p>
<pre><code>version: '2'
services:
  web:
    image: dockercloud/hello-world
    ports:
      - 8080
    networks:
      - front-tier
      - back-tier
 
  redis:
    image: redis
    links:
      - web
    networks:
      - back-tier
 
  lb:
    image: dockercloud/haproxy
    ports:
      - 80:80
    links:
      - web
    networks:
      - front-tier
      - back-tier
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock
 
networks:
  front-tier:
    driver: bridge
  back-tier:
    driver: bridge
</code></pre>
<p>常用命令：</p>
<pre><code>后台启动容器：docker-compose up -d compose文件路径
查看容器：docker-compose ps
停止容器：docker-compose stop
查看日志：docker-compose logs
</code></pre>
<p>更多命令参考：https://www.cnblogs.com/minseo/p/11548177.html</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://chiyongwu.github.io/post/hello-gridea/</id>
        <link href="https://chiyongwu.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>